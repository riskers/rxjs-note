{"./":{"url":"./","title":"关于","keywords":"","body":"rxjs note 目前 rxjs 最新版本是 v7，v4 之前的仓库是 https://github.com/Reactive-Extensions/RxJS ， v5 迁移到了 https://github.com/ReactiveX/rxjs 。 rxjs 的优势 Observable 标准化: https://github.com/tc39/proposal-observable 多语言的支持: http://reactivex.io/ 中可以看到支持的众多语言，js 只是其中一种 学习笔记 rxjs 的重点是 observable 和 observer，核心知识有 operators、subject 和 schedule。这里是我在学习 rxjs 时记录的概念和有趣的 demo。 本书发布在 https://riskers.github.io/rxjs-note/ ，感谢 github pages / gitbook / travis 提供的便利。 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"concepts/observable.html":{"url":"concepts/observable.html","title":"observable","keywords":"","body":"Observable Observable 是一个可以推送多个值的惰性集合。 单个值 多个值 拉取 Function Iterator 推送 Promise Observable 拉取 VS 推送 所谓『拉取』，就是生产者被请求时产生数据，消费者决定何时请求数据: 在拉取体系中，由消费者来决定何时从生产者那里接收数据，生产者本身不知道数据是何时交付到消费者手中的 所谓『推送』，就是生产者按自己的节奏产生数据，消费者对收到的数据做出反应: 在推送体系中，由生产者来决定何时把数据发送给消费者。消费者本身不知道何时会接收到数据 单值 VS 多值 所谓单值，就是只能返回一个值 所谓多值，就是可以随着时间的推移“返回”多个值 Function 单值 + 拉取 /* * 函数声明就是生产者，产生数据 * 函数调用就是消费者，消费数据 */ function foo() { return 42; } foo() // 只能得到一个值，永远不会是第二个值 Iterator 多值 + 拉取 /* * iter 就是生产者 * next() 是消费者，决定了何时消费 */ let arr = ['a', 'b', 'c']; let iter = arr[Symbol.iterator](); // 每一次 next() 调用得到的值都不一样，所以是多值 iter.next() // { value: 'a', done: false } iter.next() // { value: 'b', done: false } iter.next() // { value: 'c', done: false } iter.next() // { value: undefined, done: true } Promise 单值 + 推送 // 完全由 Promise 对象控制何时发送数据: then() new Promise((resolve, reject) => { // ... }) .then(data => { // ... // 只能产生一个值 }) Observable 多值 + 推送 对于 Observable 来说这个反应是 subscribe // 完全由 Observable 对象控制何时发送数据: subscribe const observable$ = Observable.create(observer => { // 每一次 next() 输出的值都不一样，所以是多值 observer.next('hi') observer.next('riskers') observer.next('hello world') setTimeout(() => { observer.next('ee') }, 2000) observer.next('last') }) observable$.subscribe({ next: (value) => console.log(value), error: err => console.log(err), complete: () => console.log('complete'), }) By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"concepts/observer.html":{"url":"concepts/observer.html","title":"observer","keywords":"","body":"Observer Observer 是 Observable 发送的值的消费者。 // 观察者只是有三个回调函数的对象，每个回调函数对应一种 Observable 发送的通知类型: const observer = { next: (value) => console.log(value), error: err => console.log(err), complete: () => console.log('complete'), } // 要使用观察者，需要把它提供给 Observable 的 subscribe 方法: observable$.subscribe(observer) subscribe 也可以是一个严格按照顺序的参数: observable$.subscribe( (val) => {console.log(val)}, err => console.log(err), () => console.log('complete'), ) By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"concepts/subject.html":{"url":"concepts/subject.html","title":"subject","keywords":"","body":"Subject 首先确定一个概念，Subject 即是 Observable 也是 Observer: stackblitz subject 在收到 $source 新消息时，会通知内部所有观察者(observerA 、observerB) 何时使用 Subject: 需要共享相同的 observable 执行。 当需要决定观察者迟来时该怎么做，是否使用 ReplaySubject、BehaviorSubject？ 需要完全控制 next()、error() 和 completed() 方法。 Cold Observable 的问题 cold ovservable 是无法多播的，因为数据不同步: stackblitz 多播 而将 cold -> hot 后，就可以多播了: stackblitz Subject 实现的多播 subject 不能重复使用 stackblitz 很多人會直接把這個特性拿來用在不知道如何建立 Observable 的狀況: class MyButton extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; this.subject = new Rx.Subject(); this.subject .mapTo(1) .scan((origin, next) => origin + next) .subscribe(x => { this.setState({ count: x }) }) } render() { return this.subject.next(event)}>{this.state.count} } } 因为 React API 的关系，如果我們想要把 React Event 转换成 observable 就可以用 Subject 幫我們做到這件事；但绝大多数的情況我們是可以透過 Observable.create 來做到這件事，像下面这样: import { Observable } from 'rxjs' const example = Observable.create(observer => { const source = getSomeSource(); // 某個数据源 source.addListener('some', (some) => { observer.next(some) }) }); 大概就會像上面這樣，如果沒有合適的 creation operators 我們還是可以利用 Observable.create 來建立 observable，除非真的因為框架限制才會直接用 Subject。 BehaviorSubject 很多時候希望 Subject 能代表當下的状态，也就是說如果今天有一個新的 subscribe，我們希望 Subject 能立即給出最新的值，而不是沒有值: stackblitz ReplaySubject 希望 Subject 代表事件，但又能在新 subscribe 时重新发送最后的几個元素 stackblitz 可能會有人以為 ReplaySubject(1) 是不是就等同於 BehaviorSubject，其實是不一樣的，BehaviorSubject 在建立時就會有起始值，比如 BehaviorSubject(0) 起始值就是 0，BehaviorSubject 是代表著狀態而 ReplaySubject 只是事件的重放而已 AsyncSubject AsyncSubject 会在 subject 结束后送出最后一個值，其实这个行为跟 Promise 很像，都是等到事情结束后送出一個值，但实际上我們非常非常少用到 AsyncSubject，絕大部分的時候都是使用 BehaviorSubject 跟 ReplaySubject 或 Subject。 stackblitz 多播操作符 multicast refCount: 建立自动 connect 的 Observable stackblitz multicast operator 实现的多播 publish multicast 的简写: var source = interval(1000).pipe( publish(), refCount() ) // 等同于: /* var source = interval(1000).pipe( multicast(new Rx.Subject()), refCount() ) */ 变体: publishBehavior var source = interval(1000).pipe( publishBehavior(0), refCount() ) // 等同于: /* var source = interval(1000).pipe( multicast(new Rx.BehaviorSubject(0)), refCount() ) */ publishReplay var source = interval(1000).pipe( publishReplay(1), refCount() ) // 等同于: /* var source = interval(1000).pipe( multicast(new Rx.ReplaySubject(1)), refCount() ) */ publishLast var source = interval(1000).pipe( publishLast(), refCount() ) // 等同于: /* var source = interval(1000).pipe( multicast(new Rx.AsyncSubject(1)), refCount() ) */ share publish + refCount 的简写: var source - interval(1000).pipe( share(), ) /* var source = interval(1000).pipe( publish(), refCount() ) */ /* var source = interval(1000).pipe( multicast(new Rx.Subject()), refCount() ) */ share operator 实现的多播 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"concepts/operators.html":{"url":"concepts/operators.html","title":"operators","keywords":"","body":"TODO By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"concepts/schedulers.html":{"url":"concepts/schedulers.html","title":"schedulers","keywords":"","body":"TODO https://stackblitz.com/edit/rxjs-6kbfxh By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"operators/":{"url":"operators/","title":"概览","keywords":"","body":"操作符 learn rxjs operators 已经很详细了，这里补充一些有意思的资料和总结。 scan: 顧名思義【掃描】就是將傳入 RxJS 運算子的事件資料，一筆一筆處理過一遍，每次處理的過程都會累加，並且處理一筆就 emit 一筆新的事件資料出來。 map: 顧名思義【對應】就是將一筆傳入的資料，對應到另一種格式的資料，通常用來轉換資料之用。 *concat: 顧名思義【串接】就是將一筆一筆的資料串接在一起，通常是把多個 Observable 物件串接成一個新的 Observable 物件。 switch: 顧名思義【交換】就是將一筆資料 \"交換成\" 另一種資料，當連續交換的事件發生時，還沒交換的資料就會被放棄。 merge: 顧名思義【合併】就是將多筆資料合併成一筆，通常是將多個 Observable 物件合併成一個 Observable 物件。 flat: 其用途跟 merge 完全一樣，在語意上，通常代表把多個 Observable 物件「壓平」成一個 Observable 物件。 exhaust: 顧名思義【耗盡】就是要把原本 Observable 物件送出的資料都跑完，才能繼續跑下一個。 zip: 這個單字有【拉鍊】的意思，你要發揮一點想像力，假設衣服的兩端，拉鍊拉起來之後，每一節都會平整的被湊在一起。 combine: 顧名思義【組合】就是將多筆資料組合在一起。 forkJoin: 這裡的 fork 是【走進岔路】的意思，Join 則是【從不同的岔路合併回來】。通常意思代表多個 Observable 物件同時執行，但全部執行完之後，才會 emit 所有資料，等大家從岔路走回來的感覺。 https://zhuanlan.zhihu.com/p/39359316： 里面的图非常有意思，多观察观察。 xxxAll: 顧名思義【全部】就是將所有傳入的 Observabe 物件，全部一起處理。 xxxLatest: 顧名思義【最新的】就是取得最新資料的意思。 xxxTo: 這裡的 To 有【表示結果】的意思，也就是直接把特定結果 emit 出去。 xxxMap: 這裡的 Map 有【對應】的意思，但是在 RxJS 的領域中，通常代表著在 Operator 中會對應到另一個不同的 Observable 物件。 xxxMapTo: 這裡就是 Map + To 的意思，但是在 RxJS 的領域中，通常代表著在 Operator 中會對應到另一個自行指定的 Observable 物件。 xxxScan: 顧名思義【掃描】就是將傳入 RxJS 運算子的事件資料，一筆一筆處理過一遍，每次處理的過程都會累加，並且處理一筆就 emit 一筆新的事件資料出來。 ---- https://blog.miniasp.com/post/2018/09/06/Clarify-some-confused-RxJS-operators.aspx By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"frameworks/rxjs-with-React/":{"url":"frameworks/rxjs-with-React/","title":"React","keywords":"","body":"TODO B / B -> C / A -> C 的通信，就建立了 3 个 Subject 对象，在一个实际应用中需要通信的部分就会更多，容易造成 subject 对象太多管理不过来。 --> By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"frameworks/rxjs-with-Angular/":{"url":"frameworks/rxjs-with-Angular/","title":"Angular","keywords":"","body":"TODO By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"debugger/tools.html":{"url":"debugger/tools.html","title":"工具","keywords":"","body":" rxMarbles rxfiddle https://jaredforsyth.com/rxvision/ https://rxviz.com/ reactive.how marbles 图怎么画 ---- https://zhuanlan.zhihu.com/p/25115712 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"debugger/test.html":{"url":"debugger/test.html","title":"测试","keywords":"","body":"使用测试弹珠来学习 rxjs By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"demos/box-drag-and-move.html":{"url":"demos/box-drag-and-move.html","title":"box-drag-and-move","keywords":"","body":"stackblitz 这是一个复杂的 stream，用 marbles 表示: move$: -(m)--(m)--(m)--(m)--(m)--(m)---- ----------------- | takeUntil | ----------------- up$: ---------------------------(u)--- | endMove$: -(m)--(m)--(m)--(m)--(m)--| down$: -(d)------------------------- map endMove$: -(m)--(m)--(m)--(m)--(m)--| | -(o)------------------------- \\ (mouseEvent) concatAll -(mouseEvent)---------------- map -(x, y)---------------------- By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"demos/race.html":{"url":"demos/race.html","title":"race-request","keywords":"","body":"竞态请求 stackblitz 在前端中经常处理请求，现在有需求: 每 10ms 请求一次百度搜索关键词，请求十个，然后显示出来。 在百度接口响应速度响应时间小于 10ms 的时候这样是没有问题的，但是这个接口响应时间在 80ms 左右，那么就会出现竞态。因为请求是异步的，只能保证发送请求的顺序是固定的，但是不能保证返回响应的顺序是一定的。可能出现先发送的请求后响应的情况 比如 但是 rxjs jsonp 就不会，因为 switchMap 会把在进行中的网络请求取消，在 10ms 后发现没有响应回来，就会取消前一个请求的订阅发下一个请求。 注意，是取消前一个请求的订阅，不是取消前一个请求，请求是一定会发出去的。 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "},"demos/eggs.html":{"url":"demos/eggs.html","title":"eggs","keywords":"","body":"彩蛋 Code 运用: bufferWhen map By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-05-30 18:20:02 "}}